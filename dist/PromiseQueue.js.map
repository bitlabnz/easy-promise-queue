{"version":3,"file":"PromiseQueue.js","sources":["../src/typeCheck.js","../src/PromiseQueue.js"],"sourcesContent":["export function isFunction (functionToCheck) {\n  return functionToCheck && Object.prototype.toString.call(functionToCheck) === '[object Function]';\n}\n\nexport function isArray (arrayToCheck) {\n  return arrayToCheck && Object.prototype.toString.call(arrayToCheck) === '[object Array]';\n}\n","import * as utils from './typeCheck';\n\nclass PromiseQueue {\n  constructor (opts) {\n    this._queue = [];\n    this._pause = false;\n    opts = Object.assign({\n      concurrency: 1,\n    }, opts);\n\n    if (opts.concurrency < 1) {\n      throw new TypeError('Expected `concurrency` to be a integer which is bigger than 0');\n    }\n\n    this._ongoingCount = 0;\n    this._concurrency = opts.concurrency;\n    this._resolveEmpty = () => {\n    };\n  }\n\n  _next () {\n    if (this._pause) {\n      return;\n    }\n\n    this._ongoingCount--;\n\n    if (this._queue.length > 0) {\n      this._queue.shift()();\n    } else {\n      this._resolveEmpty();\n    }\n  }\n\n  pause () {\n    this._pause = true;\n  }\n\n  resume () {\n    this._pause = false;\n    this._next();\n  }\n\n  add (fn) {\n    if (utils.isArray(fn) && fn.every(utils.isFunction)) {\n      return fn.length > 1 ? this.add(fn.shift()).add(fn) : this.add(fn[0]);\n    } else if (utils.isFunction(fn)) {\n      new Promise((resolve, reject) => {\n        const run = () => {\n          this._ongoingCount++;\n          fn().then(\n            val => {\n              resolve(val);\n              this._next();\n            },\n            err => {\n              reject(err);\n              this._next();\n            }\n          );\n        };\n\n        if (this._ongoingCount < this._concurrency && !this._pause) {\n          run();\n        } else {\n          this._queue.push(run);\n        }\n      });\n      return this;\n    } else {\n      throw new TypeError('Expected `arg` in add(arg) must be a function which return a Promise, or an array of function which return a Promise');\n    }\n  }\n\n  // Promises which are not ready yet to run in the queue.\n  get waitingCount () {\n    return this._queue.length;\n  }\n\n  // Promises which are running but not done.\n  get ongoingCount () {\n    return this._ongoingCount;\n  }\n}\n\nexport default PromiseQueue;"],"names":["isFunction","functionToCheck","Object","prototype","toString","call","opts","_queue","_pause","assign","concurrency","TypeError","_ongoingCount","_concurrency","_resolveEmpty","this","length","shift","_next","fn","arrayToCheck","every","utils","add","Promise","resolve","reject","run","then","val","err","_this","push"],"mappings":"wLAAO,SAASA,EAAYC,UACnBA,GAAuE,sBAApDC,OAAOC,UAAUC,SAASC,KAAKJ,yRCE5CK,gHACNC,OAAS,QACTC,QAAS,KACPN,OAAOO,OAAO,aACN,GACZH,IAEMI,YAAc,QACf,IAAIC,UAAU,sEAGjBC,cAAgB,OAChBC,aAAeP,EAAKI,iBACpBI,cAAgB,uDAKjBC,KAAKP,cAIJI,gBAEoB,EAArBG,KAAKR,OAAOS,YACTT,OAAOU,eAEPH,sDAKFN,QAAS,wCAITA,QAAS,OACTU,oCAGFC,ODvCkBC,aAAAA,ECwCHD,IDvCoD,mBAAjDjB,OAAOC,UAAUC,SAASC,KAAKe,ICuC3BD,EAAGE,MAAMC,UACb,EAAZH,EAAGH,OAAaD,KAAKQ,IAAIJ,EAAGF,SAASM,IAAIJ,GAAMJ,KAAKQ,IAAIJ,EAAG,IAC7D,GAAIG,EAAiBH,cACtBK,QAAQ,SAACC,EAASC,OACdC,EAAM,aACLf,oBACAgB,KACH,cACUC,KACHX,SAEP,cACSY,KACFZ,WAKPa,EAAKnB,cAAgBmB,EAAKlB,eAAiBkB,EAAKvB,aAG7CD,OAAOyB,KAAKL,KAGdZ,WAED,IAAIJ,UAAU,oKAMfI,KAAKR,OAAOS,mDAKZD,KAAKH"}